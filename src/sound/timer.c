#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "z80/z80intrf.h"

// This code is from raine, and replaces the crappy code which tried to handle timers
// before... !!!

// Number of cycles before reseting the cycles counter and the timers
#define MAX_CYCLES 0x40000000

// Minimum number of cycles to execute between timers tigers
#define MIN_CYCLES 100
#define VERBOSE 0
#define FPS 60

/******************************************************************/
/* This is my attempt to fix music tempo in games using the sound */
/* chip to synchronize.                                           */
/*                                                                */
/* Description of the problem : */
/* The z80 is either using an irq generated by the sound chip or */
/* is simply waiting for the sound chip status to change. These */
/* sound chips are using timers to generate their irq or to adjust */
/* their status, and we can't just reproduce these timers since */
/* the z80 is taking about 5% of the cpu time of a frame (most */
/* of the irq would happen outside of the z80 frame...) */
/* */
/* Solution : I declare my timers as static structs containing the */
/* handler and the number of cycles to be executed by the z80 before */
/* the timer is trigered. */
/* Then a special z80 frame must be executed where only the required */
/* cycles to triger a timer are executed. This slows a little down the */
/* emulation (because the z80 frame is sliced), but it's more acurate */

typedef struct {
  void (*handler)(int);
  int param;
  u32 cycles;
  u32 id;
  u32 period;
} TimerStruct;

#define MAX_TIMERS 20

static TimerStruct timer[MAX_TIMERS];
static int free_timer = 0; // index of first availale timer
static int timer_id = 1;   // id of next allocated timer
static int z80_frame;

static int dwElapsedTicks; // This will have to be maintained manually...

void update_timers(void) {
  // Called after loading a game to try to recalibrate timers...
  /* The best would probably be to save the timer array. The problem is */
  /* how to find the callbacks ??? So for now I prefer to try to guess */
  /* the correct timers... I know it's risky. */
  int n;
  int elapsed = dwElapsedTicks;
  for (n=0; n<free_timer; n++)
    if ((timer[n].cycles < elapsed) ||
	(timer[n].cycles > elapsed + z80_frame)) {
      timer[n].cycles = elapsed + MIN_CYCLES;
    }
}

void z80_irq_handler(int irq) {
  if (irq) {
    Cz80_Set_IRQ(&Cz80_struc, 0x38);
  }
#if 1
  else if (Cz80_struc.Status & CZ80_HAS_INT) {
    // When irq=0, normally the irq line goes low.
    // It seems usefull at least for rainbow Island. I should investigate
    // a little more about it one day...
    Cz80_Clear_IRQ(&Cz80_struc);
  }
#endif
}

void setup_z80_frame(u32 cpu, u32 cycles) {
  z80_frame = cycles;
  timer_id = 1;
}

void reset_timers(void) {
  free_timer = 0;
  timer_id = 1;
}

double emu_get_time(void) {
  // returns the time for the running cpu in seocnds (double)
  double time =  (double)(dwElapsedTicks+Cz80_struc.CycleIO)/(z80_frame*FPS);
  return time;
}

static int called_adjust;

void *timer_adjust(double duration, int param, double period, void (*callback)(int))
{
  u32 remaining = duration * FPS * z80_frame;
  u32 cycles_period = period * FPS * z80_frame;
  // This one is called from inside z80 emulation, so we must adjust...
  u32 elapsed = dwElapsedTicks+(Cz80_struc.CycleIO ? z80_frame-Cz80_struc.CycleIO : 0);
  if (remaining < Cz80_struc.CycleIO) {
    printf("*** Asked for a new timer with cycles = %d, frame left %d\n",remaining,Cz80_struc.CycleIO);
    Cz80_struc.CycleIO = remaining; // this is a very good point of cz80 !!!
  }

  called_adjust = 1;
  if (free_timer < MAX_TIMERS) {
#if VERBOSE
      fprintf(stderr,"timer_set %g cycles %d fps %d z80_frame %d id %d period %d\n",duration,remaining,FPS,z80_frame,timer_id,cycles_period);
#endif
    timer[free_timer].handler = callback;
    timer[free_timer].param = param;
    timer[free_timer].cycles = elapsed + remaining;
    timer[free_timer].id = timer_id;
    timer[free_timer].period = cycles_period;
    free_timer++;
  } else {
    // fprintf(stderr,"free timers overflow !!!\n");
    return NULL;
    // exit(1);
  }
  return (void*)timer_id++;
}

void timer_remove(void *the_timer) {
  int n;
  u32 id = (u32)the_timer;
#if VERBOSE
  fprintf(stderr,"CALLED timer_remove %d\n",id);
#endif
  for (n=0; n<free_timer; n++) {
    if (timer[n].id == id)
      break;
  }
  if (n<free_timer) { // found ?
    if (n<free_timer-1) // Not the last one ?
      memmove(&timer[n],&timer[n+1],sizeof(TimerStruct)*(free_timer-n-1));
    free_timer--;
  }
#if VERBOSE
  fprintf(stderr,"after removal free %d\n",free_timer);
#endif
}

void triger_timers(void) {
  u32 elapsed = dwElapsedTicks;
  int n;
#if VERBOSE
  int count=0;
#endif

#if 0
  for (n=0; n<free_timer; n++) {
    if (timer[n].cycles <= elapsed) { // Trigered !
      count++;
    }
  }
#endif

  for (n=0; n<free_timer; n++) {
    if (timer[n].cycles <= elapsed) { // Trigered !
#if VERBOSE
      fprintf(stderr,"timer %d elapsed %d diff %d\n",n,elapsed,elapsed - timer[n].cycles);
#endif
#if 1
      if (!Cz80_struc.IFF.W) {
	// Sometimes 2 timers trigger too close to each other and the z80
	// needs time to handle the interrupt.
	// I really wonder how the original hardware handled this.
	// Maybe there was a minimum delay on the line ?

	// Anyway this has to happen BEFORE the timer is trigered because
	// if an external interrupt blocks the timer int, even if it makes
	// it pending, it can produce 2 interrupts too close to each other
	// which has the effect of completely stopping the music !
	int cycles;
	ExitOnEI = 1; // Exit at the end of the interrupt
	cycles = mz80exec(60000);
	if (!Cz80_struc.IFF.W) {
	  ExitOnEI = 1; // Exit at the end of the interrupt
	  cycles = mz80exec(60000);
	}
      }
#endif
      called_adjust = 0;
      (*(timer[n].handler))(timer[n].param);
      // Normally, I would call timer_remove here :
      // timer_remove((void*)timer[n].id);
      // but it is rather unefficient since it's looking for a timer
      // when we know whcih one we want to delete...
      // Also, it allows to handle periodic timers
      if (!called_adjust) {
	if (timer[n].period) {
	  timer[n].cycles = elapsed + timer[n].period;
	} else {
	  if (n<free_timer-1) // not the last timer ?
	    memmove(&timer[n],&timer[n+1],sizeof(TimerStruct)*(free_timer-n-1));
	  free_timer--;
	  n--;
	}
      }
    }
  }
  if (elapsed > MAX_CYCLES) { // time to reset the cpu...
    for (n=0; n<free_timer; n++)
      timer[n].cycles -= MAX_CYCLES;
    dwElapsedTicks -= MAX_CYCLES;
  }
#if VERBOSE
  if (count > 1)
    fprintf(stderr,"*** WARNING triger %d\n",count);
#endif
}

s32 get_min_cycles(u32 frame) {
  int n;
  u32 elapsed;
  s32 min_cycles;

  elapsed = dwElapsedTicks;
  if (free_timer > 0) {
    min_cycles = timer[0].cycles;
    for (n=1; n<free_timer; n++)
      if (timer[n].cycles < min_cycles)
	min_cycles = timer[n].cycles;
    min_cycles -= elapsed;

    if (min_cycles <= MIN_CYCLES) {
      min_cycles = MIN_CYCLES;
    }
    if (min_cycles > frame) {
      min_cycles = frame;
    }
  } else {
    min_cycles = frame;
  }
#if VERBOSE
  fprintf(stderr,"asked %d\n",min_cycles);
  if (min_cycles < 0) {
    fprintf(stderr,"cycles FIXED to 1000\n");
    min_cycles = 500;
    exit(1);
  }
#endif
  return min_cycles;
}

int execute_one_z80_audio_frame(u32 frame) {
    u32 elapsed = dwElapsedTicks;
    s32 min_cycles = get_min_cycles(frame);

    dwElapsedTicks += mz80exec(min_cycles);        // Sound Z80
    frame = (dwElapsedTicks - elapsed); // min_cycles;
#if VERBOSE
    if (abs(frame - min_cycles) > 16)
      fprintf(stderr,"diff %d (pc %x)\n",dwElapsedTicks - elapsed - min_cycles,Cz80_struc.PC - Cz80_struc.BasePC);
#endif

    triger_timers();
    //fprintf(stderr,"%d\n",frame-min_cycles);
  return frame;
}

void finish_speed_hack(s32 diff) {
  s32 min;
  while (diff > 0) {
    min = get_min_cycles(diff);
    dwElapsedTicks += min;
    triger_timers();
    diff -= min;
  }
}

void execute_z80_audio_frame() {
  s32 frame = z80_frame;
  while (frame > 0) {
    frame -= execute_one_z80_audio_frame(frame);
  }
}
